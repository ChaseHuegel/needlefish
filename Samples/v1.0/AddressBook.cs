/// <auto-generated>
/// Generated by the nsd compiler. Do not modify!
/// Language version: 1
/// Source: AddressBook
/// </auto-generated>

#pragma warning disable CS0219 // Variable is assigned but its value is never used
#pragma warning disable CS8602 // Dereference of a possibly null reference.
using System;
using System.Buffers.Binary;

namespace Samples.Nsd
{
    public enum PhoneType
    {
        Unknown = 0,
        Mobile = 1,
        Home = 5,
        Work = 6,
    }
    
    public struct Person
    {
        #region Field identifiers
        private const ushort Id_ID = 0;
        private const ushort Name_ID = 1;
        private const ushort Email_ID = 2;
        private const ushort Phones_ID = 10;
        #endregion
        
        public int Id;
        public string Name;
        public string? Email;
        public PhoneNumber[]? Phones;
        
        public Person(int _Id, string _Name, string? _Email, PhoneNumber[]? _Phones)
        {
            Id = _Id;
            Name = _Name;
            Email = _Email;
            Phones = _Phones;
            
        }
        
        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;
            
            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion
        
            #region Static size calculation
            const int Id_MinLen = fieldHeaderLen + intLen;
            const int Name_MinLen = fieldHeaderLen + arrayHeaderLen;
            #endregion
        
            const int minLength = Id_MinLen
                + Name_MinLen;
        
            int length = minLength;
        
            #region Dynamic size calculation
            if (Name != null)
            {
                length += Name.Length * charLen;
            }
        
            if (Email != null)
            {
                length += optionalFieldLen + arrayHeaderLen + Email.Length * charLen;
            }
        
            if (Phones != null)
            {
                length += optionalFieldLen + arrayHeaderLen + (Phones.Length * 0);
                for (int i = 0; i < Phones.Length; i++)
                {
                    length += arrayHeaderLen + Phones[i].GetSize();
                }
            }
        
            #endregion
        
            return length;
        }
        
        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }
        
        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize Id
                    int g__Id = Id;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Id_ID : BinaryPrimitives.ReverseEndianness(Id_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Id : BinaryPrimitives.ReverseEndianness(g__Id);
                        offset += 4;
                    #endregion
                    
                    #region Serialize Name
                    string g__Name = Name;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Name_ID : BinaryPrimitives.ReverseEndianness(Name_ID);
                        offset += 2;
                    
                    if (g__Name != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Name?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Name?.Length ?? 0));
                        offset += 2;
                    
                        for (int i = 0; i < g__Name.Length; i++)
                        {
                            *((char*)offset) = BitConverter.IsLittleEndian ? g__Name[i] : (char)BinaryPrimitives.ReverseEndianness(g__Name[i]);
                            offset += 2;
                        }
                    }
                    else
                    {
                        *((ushort*)offset) = (ushort)0;
                        offset += 2;
                    }
                    #endregion
                    
                    #region Serialize Email
                    string? g__Email = Email;
                    if (g__Email != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Email_ID : BinaryPrimitives.ReverseEndianness(Email_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Email?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Email?.Length ?? 0));
                        offset += 2;
                    
                        for (int i = 0; i < g__Email?.Length; i++)
                        {
                            *((char*)offset) = BitConverter.IsLittleEndian ? g__Email[i] : (char)BinaryPrimitives.ReverseEndianness(g__Email[i]);
                            offset += 2;
                        }
                    }
                    #endregion
                    
                    #region Serialize Phones
                    PhoneNumber[]? g__Phones = Phones;
                    if (g__Phones != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Phones_ID : BinaryPrimitives.ReverseEndianness(Phones_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Phones?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Phones?.Length ?? 0));
                        offset += 2;
                    
                        for (int i = 0; i < g__Phones?.Length; i++)
                        {
                            ushort g__Phones_ObjectLength = (ushort)g__Phones[i].GetSize();
                        * ((ushort*)offset) = BitConverter.IsLittleEndian ? g__Phones_ObjectLength : BinaryPrimitives.ReverseEndianness(g__Phones_ObjectLength);
                        offset += 2;
                    
                        g__Phones[i].SerializeInto(buffer, (int)(offset - b));
                        offset += g__Phones_ObjectLength;
                        }
                    }
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public static Person Deserialize(byte[] buffer, int start, int length)
        {
            Person value = new Person();
            value.Unpack(buffer, start, length);
            return value;
        }
        
        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__Id_Read = false;
                    bool g__Name_Read = false;
                    bool g__Email_Read = false;
                    bool g__Phones_Read = false;
                    
        
                    while (readsCompleted < 4 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize Id
                            case Id_ID:
                                if (g__Id_Read)
                                {
                                    break;
                                }
                            
                                Id = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Id_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Name
                            case Name_ID:
                                if (g__Name_Read)
                                {
                                    break;
                                }
                            
                                ushort g__Name_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__Name_Length == 0)
                                {
                                    Name = string.Empty;
                                }
                                else
                                {
                                    char* chars = (char*)offset;
                                    if (!BitConverter.IsLittleEndian)
                                    {
                                        for (int n = 0; n < g__Name_Length; n++)
                                        {
                                            *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                            chars += 2;
                                        }
                                    }
                                
                                    Name = new string(chars, 0, g__Name_Length);
                                    offset += 2 * g__Name_Length;
                                }
                                
                            
                                g__Name_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Email
                            case Email_ID:
                                if (g__Email_Read)
                                {
                                    break;
                                }
                            
                                bool g__Email_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Email_HasValue)
                                {
                                    ushort g__Email_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                    if (g__Email_Length == 0)
                                    {
                                        Email = string.Empty;
                                    }
                                    else
                                    {
                                        char* chars = (char*)offset;
                                        if (!BitConverter.IsLittleEndian)
                                        {
                                            for (int n = 0; n < g__Email_Length; n++)
                                            {
                                                *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                                chars += 2;
                                            }
                                        }
                                
                                        Email = new string(chars, 0, g__Email_Length);
                                        offset += 2 * g__Email_Length;
                                    }
                                }
                                else
                                {
                                    Email = null;
                                }
                                
                            
                                g__Email_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Phones
                            case Phones_ID:
                                if (g__Phones_Read)
                                {
                                    break;
                                }
                            
                                bool g__Phones_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Phones_HasValue)
                                {
                                    ushort g__Phones_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                    if (g__Phones_Length == 0)
                                    {
                                        Phones = Array.Empty<PhoneNumber>();
                                    }
                                    else
                                    {
                                        Phones = new PhoneNumber[g__Phones_Length];
                                
                                        for (int i = 0; i < g__Phones_Length; i++)
                                        {
                                            ushort g__Phones_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                            int g__Phones_Start = (int)(offset - b);
                            Phones[i].Unpack(buffer, g__Phones_Start, g__Phones_ObjectLength);
                            offset += g__Phones_ObjectLength;
                                        }
                                    }
                                }
                                else
                                {
                                    Phones = null;
                                }
                                
                            
                                g__Phones_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
    }
    
    public struct PhoneNumber
    {
        #region Field identifiers
        private const ushort Number_ID = 0;
        private const ushort Type_ID = 1;
        #endregion
        
        public string Number;
        public PhoneType Type;
        
        public PhoneNumber(string _Number, PhoneType _Type)
        {
            Number = _Number;
            Type = _Type;
            
        }
        
        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;
            
            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion
        
            #region Static size calculation
            const int Number_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int Type_MinLen = fieldHeaderLen + enumLen;
            #endregion
        
            const int minLength = Number_MinLen
                + Type_MinLen;
        
            int length = minLength;
        
            #region Dynamic size calculation
            if (Number != null)
            {
                length += Number.Length * charLen;
            }
        
            #endregion
        
            return length;
        }
        
        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }
        
        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize Number
                    string g__Number = Number;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Number_ID : BinaryPrimitives.ReverseEndianness(Number_ID);
                        offset += 2;
                    
                    if (g__Number != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Number?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Number?.Length ?? 0));
                        offset += 2;
                    
                        for (int i = 0; i < g__Number.Length; i++)
                        {
                            *((char*)offset) = BitConverter.IsLittleEndian ? g__Number[i] : (char)BinaryPrimitives.ReverseEndianness(g__Number[i]);
                            offset += 2;
                        }
                    }
                    else
                    {
                        *((ushort*)offset) = (ushort)0;
                        offset += 2;
                    }
                    #endregion
                    
                    #region Serialize Type
                    PhoneType g__Type = Type;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Type_ID : BinaryPrimitives.ReverseEndianness(Type_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? (int)g__Type : BinaryPrimitives.ReverseEndianness((int)g__Type);
                        offset += 4;
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public static PhoneNumber Deserialize(byte[] buffer, int start, int length)
        {
            PhoneNumber value = new PhoneNumber();
            value.Unpack(buffer, start, length);
            return value;
        }
        
        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__Number_Read = false;
                    bool g__Type_Read = false;
                    
        
                    while (readsCompleted < 2 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize Number
                            case Number_ID:
                                if (g__Number_Read)
                                {
                                    break;
                                }
                            
                                ushort g__Number_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__Number_Length == 0)
                                {
                                    Number = string.Empty;
                                }
                                else
                                {
                                    char* chars = (char*)offset;
                                    if (!BitConverter.IsLittleEndian)
                                    {
                                        for (int n = 0; n < g__Number_Length; n++)
                                        {
                                            *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                            chars += 2;
                                        }
                                    }
                                
                                    Number = new string(chars, 0, g__Number_Length);
                                    offset += 2 * g__Number_Length;
                                }
                                
                            
                                g__Number_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Type
                            case Type_ID:
                                if (g__Type_Read)
                                {
                                    break;
                                }
                            
                                Type = (PhoneType)(BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset)));
                            offset += 4;
                                
                            
                                g__Type_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
    }
    
    public struct AddressBook
    {
        #region Field identifiers
        private const ushort People_ID = 0;
        #endregion
        
        public Person[] People;
        
        public AddressBook(Person[] _People)
        {
            People = _People;
            
        }
        
        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;
            
            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion
        
            #region Static size calculation
            const int People_MinLen = fieldHeaderLen + arrayHeaderLen;
            #endregion
        
            const int minLength = People_MinLen;
        
            int length = minLength;
        
            #region Dynamic size calculation
            if (People != null)
            {
                for (int i = 0; i < People.Length; i++)
                {
                    length += arrayHeaderLen + People[i].GetSize();
                }
            }
        
            #endregion
        
            return length;
        }
        
        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }
        
        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize People
                    Person[] g__People = People;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? People_ID : BinaryPrimitives.ReverseEndianness(People_ID);
                        offset += 2;
                    
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__People?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__People?.Length ?? 0));
                        offset += 2;
                    
                    for (int i = 0; i < g__People?.Length; i++)
                    {
                        ushort g__People_ObjectLength = (ushort)g__People[i].GetSize();
                        * ((ushort*)offset) = BitConverter.IsLittleEndian ? g__People_ObjectLength : BinaryPrimitives.ReverseEndianness(g__People_ObjectLength);
                        offset += 2;
                    
                        g__People[i].SerializeInto(buffer, (int)(offset - b));
                        offset += g__People_ObjectLength;
                    }
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public static AddressBook Deserialize(byte[] buffer, int start, int length)
        {
            AddressBook value = new AddressBook();
            value.Unpack(buffer, start, length);
            return value;
        }
        
        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__People_Read = false;
                    
        
                    while (readsCompleted < 1 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize People
                            case People_ID:
                                if (g__People_Read)
                                {
                                    break;
                                }
                            
                                ushort g__People_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__People_Length == 0)
                                {
                                    People = Array.Empty<Person>();
                                }
                                else
                                {
                                    People = new Person[g__People_Length];
                                
                                    for (int i = 0; i < g__People_Length; i++)
                                    {
                                        ushort g__People_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                            int g__People_Start = (int)(offset - b);
                            People[i].Unpack(buffer, g__People_Start, g__People_ObjectLength);
                            offset += g__People_ObjectLength;
                                    }
                                }
                                
                            
                                g__People_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
    }
    
}
