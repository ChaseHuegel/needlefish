/// <auto-generated>
/// Generated by the nsd compiler. Do not modify!
/// Language version: 1
/// Source: LexerTests.ValidNsd
/// </auto-generated>

#pragma warning disable CS0219 // Variable is assigned but its value is never used
#pragma warning disable CS8602 // Dereference of a possibly null reference.
using System;
using System.Buffers.Binary;

namespace Lexer.Tests
{
    public enum TestEnum
    {
        Val1 = 0,
        Val2 = 10,
        Val3 = 11,
        Val4 = 12,
    }

    public struct TestMessage
    {
        #region Field identifiers
        private const ushort Content_ID = 0;
        private const ushort Body_ID = 1;
        private const ushort FloAT_ID = 2;
        private const ushort Double_ID = 3;
        private const ushort Long_ID = 4;
        private const ushort uLong_ID = 5;
        private const ushort Ulong_ID = 15;
        private const ushort Short_ID = 16;
        private const ushort UShort_ID = 17;
        private const ushort Bool_ID = 18;
        private const ushort Byte_ID = 19;
        private const ushort Bytes_ID = 21;
        private const ushort OptionalStrings_ID = 30;
        private const ushort Int_ID = 31;
        private const ushort OptionalInt_ID = 32;
        private const ushort Ints_ID = 33;
        private const ushort OptionalInts_ID = 34;
        private const ushort UInt_ID = 35;
        private const ushort OptionalUInt_ID = 36;
        private const ushort UInts_ID = 37;
        private const ushort OptionalUInts_ID = 38;
        private const ushort Enum_ID = 22;
        private const ushort OptionalEnum_ID = 23;
        private const ushort Enums_ID = 24;
        private const ushort OptionalEnums_ID = 25;
        private const ushort Submessage_ID = 26;
        private const ushort OptionalSubmessage_ID = 27;
        private const ushort Submessages_ID = 28;
        private const ushort OptionalSubmessages_ID = 29;
        #endregion

        public string? Content;
        public string Body;
        public float FloAT;
        public double Double;
        public long Long;
        public ulong uLong;
        public ulong Ulong;
        public short Short;
        public ushort UShort;
        public bool Bool;
        public byte Byte;
        public byte[] Bytes;
        public string[]? OptionalStrings;
        public int Int;
        public int? OptionalInt;
        public int[] Ints;
        public int[]? OptionalInts;
        public uint UInt;
        public uint? OptionalUInt;
        public uint[] UInts;
        public uint[]? OptionalUInts;
        public TestEnum Enum;
        public TestEnum? OptionalEnum;
        public TestEnum[] Enums;
        public TestEnum[]? OptionalEnums;
        public Submessage Submessage;
        public Submessage? OptionalSubmessage;
        public Submessage[] Submessages;
        public Submessage[]? OptionalSubmessages;

        public TestMessage(string? _Content, string _Body, float _FloAT, double _Double, long _Long, ulong _uLong, ulong _Ulong, short _Short, ushort _UShort, bool _Bool, byte _Byte, byte[] _Bytes, string[]? _OptionalStrings, int _Int, int? _OptionalInt, int[] _Ints, int[]? _OptionalInts, uint _UInt, uint? _OptionalUInt, uint[] _UInts, uint[]? _OptionalUInts, TestEnum _Enum, TestEnum? _OptionalEnum, TestEnum[] _Enums, TestEnum[]? _OptionalEnums, Submessage _Submessage, Submessage? _OptionalSubmessage, Submessage[] _Submessages, Submessage[]? _OptionalSubmessages)
        {
            Content = _Content;
            Body = _Body;
            FloAT = _FloAT;
            Double = _Double;
            Long = _Long;
            uLong = _uLong;
            Ulong = _Ulong;
            Short = _Short;
            UShort = _UShort;
            Bool = _Bool;
            Byte = _Byte;
            Bytes = _Bytes;
            OptionalStrings = _OptionalStrings;
            Int = _Int;
            OptionalInt = _OptionalInt;
            Ints = _Ints;
            OptionalInts = _OptionalInts;
            UInt = _UInt;
            OptionalUInt = _OptionalUInt;
            UInts = _UInts;
            OptionalUInts = _OptionalUInts;
            Enum = _Enum;
            OptionalEnum = _OptionalEnum;
            Enums = _Enums;
            OptionalEnums = _OptionalEnums;
            Submessage = _Submessage;
            OptionalSubmessage = _OptionalSubmessage;
            Submessages = _Submessages;
            OptionalSubmessages = _OptionalSubmessages;

        }

        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;

            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion

            #region Static size calculation
            const int Body_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int FloAT_MinLen = fieldHeaderLen + floatLen;
            const int Double_MinLen = fieldHeaderLen + doubleLen;
            const int Long_MinLen = fieldHeaderLen + longLen;
            const int uLong_MinLen = fieldHeaderLen + longLen;
            const int Ulong_MinLen = fieldHeaderLen + longLen;
            const int Short_MinLen = fieldHeaderLen + shortLen;
            const int UShort_MinLen = fieldHeaderLen + shortLen;
            const int Bool_MinLen = fieldHeaderLen + boolLen;
            const int Byte_MinLen = fieldHeaderLen + byteLen;
            const int Bytes_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int Int_MinLen = fieldHeaderLen + intLen;
            const int Ints_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int UInt_MinLen = fieldHeaderLen + intLen;
            const int UInts_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int Enum_MinLen = fieldHeaderLen + enumLen;
            const int Enums_MinLen = fieldHeaderLen + arrayHeaderLen;
            const int Submessage_MinLen = fieldHeaderLen + 0;
            const int Submessages_MinLen = fieldHeaderLen + arrayHeaderLen;
            #endregion

            const int minLength = Body_MinLen
                + FloAT_MinLen
                + Double_MinLen
                + Long_MinLen
                + uLong_MinLen
                + Ulong_MinLen
                + Short_MinLen
                + UShort_MinLen
                + Bool_MinLen
                + Byte_MinLen
                + Bytes_MinLen
                + Int_MinLen
                + Ints_MinLen
                + UInt_MinLen
                + UInts_MinLen
                + Enum_MinLen
                + Enums_MinLen
                + Submessage_MinLen
                + Submessages_MinLen;

            int length = minLength;

            #region Dynamic size calculation
            if (Content != null)
            {
                length += optionalFieldLen + arrayHeaderLen + Content.Length * charLen;
            }

            if (Body != null)
            {
                length += Body.Length * charLen;
            }

            if (Bytes != null)
            {
                length += (Bytes.Length * byteLen);
            }

            if (OptionalStrings != null)
            {
                length += optionalFieldLen + arrayHeaderLen + 0;
                for (int i = 0; i < OptionalStrings.Length; i++)
                {
                    length += arrayHeaderLen + OptionalStrings[i].Length * charLen;
                }
            }

            if (OptionalInt != null)
            {
                length += optionalFieldLen + intLen;
            }

            if (Ints != null)
            {
                length += (Ints.Length * intLen);
            }

            if (OptionalInts != null)
            {
                length += optionalFieldLen + arrayHeaderLen + (OptionalInts.Length * intLen);
            }

            if (OptionalUInt != null)
            {
                length += optionalFieldLen + intLen;
            }

            if (UInts != null)
            {
                length += (UInts.Length * intLen);
            }

            if (OptionalUInts != null)
            {
                length += optionalFieldLen + arrayHeaderLen + (OptionalUInts.Length * intLen);
            }

            if (OptionalEnum != null)
            {
                length += optionalFieldLen + enumLen;
            }

            if (Enums != null)
            {
                length += (Enums.Length * enumLen);
            }

            if (OptionalEnums != null)
            {
                length += optionalFieldLen + arrayHeaderLen + (OptionalEnums.Length * enumLen);
            }

            length += arrayHeaderLen + Submessage.GetSize();

            if (OptionalSubmessage != null)
            {
                length += optionalFieldLen + arrayHeaderLen + OptionalSubmessage.Value.GetSize();
            }

            if (Submessages != null)
            {
                for (int i = 0; i < Submessages.Length; i++)
                {
                    length += arrayHeaderLen + Submessages[i].GetSize();
                }
            }

            if (OptionalSubmessages != null)
            {
                length += optionalFieldLen + arrayHeaderLen + (OptionalSubmessages.Length * 0);
                for (int i = 0; i < OptionalSubmessages.Length; i++)
                {
                    length += arrayHeaderLen + OptionalSubmessages[i].GetSize();
                }
            }

            #endregion

            return length;
        }

        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }

        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;

                    #region Serialize Content
                    string? g__Content = Content;
                    if (g__Content != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Content_ID : BinaryPrimitives.ReverseEndianness(Content_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Content?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Content?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__Content?.Length; i++)
                        {
                            *((char*)offset) = BitConverter.IsLittleEndian ? g__Content[i] : (char)BinaryPrimitives.ReverseEndianness(g__Content[i]);
                            offset += 2;
                        }
                    }
                    #endregion

                    #region Serialize Body
                    string g__Body = Body;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Body_ID : BinaryPrimitives.ReverseEndianness(Body_ID);
                    offset += 2;

                    if (g__Body != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Body?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Body?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__Body.Length; i++)
                        {
                            *((char*)offset) = BitConverter.IsLittleEndian ? g__Body[i] : (char)BinaryPrimitives.ReverseEndianness(g__Body[i]);
                            offset += 2;
                        }
                    }
                    else
                    {
                        *((ushort*)offset) = (ushort)0;
                        offset += 2;
                    }
                    #endregion

                    #region Serialize FloAT
                    float g__FloAT = FloAT;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? FloAT_ID : BinaryPrimitives.ReverseEndianness(FloAT_ID);
                    offset += 2;

                    float g__FloAT_Copy = g__FloAT;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__FloAT : BinaryPrimitives.ReverseEndianness(*(uint*)&g__FloAT_Copy);
                    offset += 4;
                    #endregion

                    #region Serialize Double
                    double g__Double = Double;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Double_ID : BinaryPrimitives.ReverseEndianness(Double_ID);
                    offset += 2;

                    double g__Double_Copy = g__Double;
                    *((double*)offset) = BitConverter.IsLittleEndian ? g__Double : BinaryPrimitives.ReverseEndianness(*(ulong*)&g__Double_Copy);
                    offset += 8;
                    #endregion

                    #region Serialize Long
                    long g__Long = Long;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Long_ID : BinaryPrimitives.ReverseEndianness(Long_ID);
                    offset += 2;

                    *((long*)offset) = BitConverter.IsLittleEndian ? g__Long : BinaryPrimitives.ReverseEndianness(g__Long);
                    offset += 8;
                    #endregion

                    #region Serialize uLong
                    ulong g__uLong = uLong;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? uLong_ID : BinaryPrimitives.ReverseEndianness(uLong_ID);
                    offset += 2;

                    *((ulong*)offset) = BitConverter.IsLittleEndian ? g__uLong : BinaryPrimitives.ReverseEndianness(g__uLong);
                    offset += 8;
                    #endregion

                    #region Serialize Ulong
                    ulong g__Ulong = Ulong;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Ulong_ID : BinaryPrimitives.ReverseEndianness(Ulong_ID);
                    offset += 2;

                    *((ulong*)offset) = BitConverter.IsLittleEndian ? g__Ulong : BinaryPrimitives.ReverseEndianness(g__Ulong);
                    offset += 8;
                    #endregion

                    #region Serialize Short
                    short g__Short = Short;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Short_ID : BinaryPrimitives.ReverseEndianness(Short_ID);
                    offset += 2;

                    *((short*)offset) = BitConverter.IsLittleEndian ? g__Short : BinaryPrimitives.ReverseEndianness(g__Short);
                    offset += 2;
                    #endregion

                    #region Serialize UShort
                    ushort g__UShort = UShort;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? UShort_ID : BinaryPrimitives.ReverseEndianness(UShort_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? g__UShort : BinaryPrimitives.ReverseEndianness(g__UShort);
                    offset += 2;
                    #endregion

                    #region Serialize Bool
                    bool g__Bool = Bool;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Bool_ID : BinaryPrimitives.ReverseEndianness(Bool_ID);
                    offset += 2;

                    *((bool*)offset) = g__Bool;
                    offset += 1;
                    #endregion

                    #region Serialize Byte
                    byte g__Byte = Byte;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Byte_ID : BinaryPrimitives.ReverseEndianness(Byte_ID);
                    offset += 2;

                    *((byte*)offset) = BitConverter.IsLittleEndian ? g__Byte : BinaryPrimitives.ReverseEndianness(g__Byte);
                    offset += 1;
                    #endregion

                    #region Serialize Bytes
                    byte[] g__Bytes = Bytes;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Bytes_ID : BinaryPrimitives.ReverseEndianness(Bytes_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Bytes?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Bytes?.Length ?? 0));
                    offset += 2;

                    for (int i = 0; i < g__Bytes?.Length; i++)
                    {
                        *((byte*)offset) = BitConverter.IsLittleEndian ? g__Bytes[i] : BinaryPrimitives.ReverseEndianness(g__Bytes[i]);
                        offset += 1;
                    }
                    #endregion

                    #region Serialize OptionalStrings
                    string[]? g__OptionalStrings = OptionalStrings;
                    if (g__OptionalStrings != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalStrings_ID : BinaryPrimitives.ReverseEndianness(OptionalStrings_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__OptionalStrings?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__OptionalStrings?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__OptionalStrings?.Length; i++)
                        {
                            string item = g__OptionalStrings[i];

                            *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(item?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(item?.Length ?? 0));
                            offset += 2;

                            if (item != null)
                            {
                                for (int n = 0; n < item.Length; n++)
                                {
                                    *((char*)offset) = BitConverter.IsLittleEndian ? item[n] : (char)BinaryPrimitives.ReverseEndianness(item[n]);
                                    offset += 2;
                                }
                            }
                        }
                    }
                    #endregion

                    #region Serialize Int
                    int g__Int = Int;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Int_ID : BinaryPrimitives.ReverseEndianness(Int_ID);
                    offset += 2;

                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Int : BinaryPrimitives.ReverseEndianness(g__Int);
                    offset += 4;
                    #endregion

                    #region Serialize OptionalInt
                    int? g__OptionalInt = OptionalInt;
                    if (g__OptionalInt != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalInt_ID : BinaryPrimitives.ReverseEndianness(OptionalInt_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((int*)offset) = BitConverter.IsLittleEndian ? g__OptionalInt.Value : BinaryPrimitives.ReverseEndianness(g__OptionalInt.Value);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize Ints
                    int[] g__Ints = Ints;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Ints_ID : BinaryPrimitives.ReverseEndianness(Ints_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Ints?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Ints?.Length ?? 0));
                    offset += 2;

                    for (int i = 0; i < g__Ints?.Length; i++)
                    {
                        *((int*)offset) = BitConverter.IsLittleEndian ? g__Ints[i] : BinaryPrimitives.ReverseEndianness(g__Ints[i]);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize OptionalInts
                    int[]? g__OptionalInts = OptionalInts;
                    if (g__OptionalInts != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalInts_ID : BinaryPrimitives.ReverseEndianness(OptionalInts_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__OptionalInts?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__OptionalInts?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__OptionalInts?.Length; i++)
                        {
                            *((int*)offset) = BitConverter.IsLittleEndian ? g__OptionalInts[i] : BinaryPrimitives.ReverseEndianness(g__OptionalInts[i]);
                            offset += 4;
                        }
                    }
                    #endregion

                    #region Serialize UInt
                    uint g__UInt = UInt;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? UInt_ID : BinaryPrimitives.ReverseEndianness(UInt_ID);
                    offset += 2;

                    *((uint*)offset) = BitConverter.IsLittleEndian ? g__UInt : BinaryPrimitives.ReverseEndianness(g__UInt);
                    offset += 4;
                    #endregion

                    #region Serialize OptionalUInt
                    uint? g__OptionalUInt = OptionalUInt;
                    if (g__OptionalUInt != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalUInt_ID : BinaryPrimitives.ReverseEndianness(OptionalUInt_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((uint*)offset) = BitConverter.IsLittleEndian ? g__OptionalUInt.Value : BinaryPrimitives.ReverseEndianness(g__OptionalUInt.Value);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize UInts
                    uint[] g__UInts = UInts;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? UInts_ID : BinaryPrimitives.ReverseEndianness(UInts_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__UInts?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__UInts?.Length ?? 0));
                    offset += 2;

                    for (int i = 0; i < g__UInts?.Length; i++)
                    {
                        *((uint*)offset) = BitConverter.IsLittleEndian ? g__UInts[i] : BinaryPrimitives.ReverseEndianness(g__UInts[i]);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize OptionalUInts
                    uint[]? g__OptionalUInts = OptionalUInts;
                    if (g__OptionalUInts != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalUInts_ID : BinaryPrimitives.ReverseEndianness(OptionalUInts_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__OptionalUInts?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__OptionalUInts?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__OptionalUInts?.Length; i++)
                        {
                            *((uint*)offset) = BitConverter.IsLittleEndian ? g__OptionalUInts[i] : BinaryPrimitives.ReverseEndianness(g__OptionalUInts[i]);
                            offset += 4;
                        }
                    }
                    #endregion

                    #region Serialize Enum
                    TestEnum g__Enum = Enum;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Enum_ID : BinaryPrimitives.ReverseEndianness(Enum_ID);
                    offset += 2;

                    *((int*)offset) = BitConverter.IsLittleEndian ? (int)g__Enum : BinaryPrimitives.ReverseEndianness((int)g__Enum);
                    offset += 4;
                    #endregion

                    #region Serialize OptionalEnum
                    TestEnum? g__OptionalEnum = OptionalEnum;
                    if (g__OptionalEnum != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalEnum_ID : BinaryPrimitives.ReverseEndianness(OptionalEnum_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((int*)offset) = BitConverter.IsLittleEndian ? (int)g__OptionalEnum.Value : BinaryPrimitives.ReverseEndianness((int)g__OptionalEnum.Value);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize Enums
                    TestEnum[] g__Enums = Enums;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Enums_ID : BinaryPrimitives.ReverseEndianness(Enums_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Enums?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Enums?.Length ?? 0));
                    offset += 2;

                    for (int i = 0; i < g__Enums?.Length; i++)
                    {
                        *((int*)offset) = BitConverter.IsLittleEndian ? (int)g__Enums[i] : BinaryPrimitives.ReverseEndianness((int)g__Enums[i]);
                        offset += 4;
                    }
                    #endregion

                    #region Serialize OptionalEnums
                    TestEnum[]? g__OptionalEnums = OptionalEnums;
                    if (g__OptionalEnums != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalEnums_ID : BinaryPrimitives.ReverseEndianness(OptionalEnums_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__OptionalEnums?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__OptionalEnums?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__OptionalEnums?.Length; i++)
                        {
                            *((int*)offset) = BitConverter.IsLittleEndian ? (int)g__OptionalEnums[i] : BinaryPrimitives.ReverseEndianness((int)g__OptionalEnums[i]);
                            offset += 4;
                        }
                    }
                    #endregion

                    #region Serialize Submessage
                    Submessage g__Submessage = Submessage;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Submessage_ID : BinaryPrimitives.ReverseEndianness(Submessage_ID);
                    offset += 2;

                    ushort g__Submessage_ObjectLength = (ushort)g__Submessage.GetSize();
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? g__Submessage_ObjectLength : BinaryPrimitives.ReverseEndianness(g__Submessage_ObjectLength);
                    offset += 2;

                    g__Submessage.SerializeInto(buffer, (int)(offset - b));
                    offset += g__Submessage_ObjectLength;
                    #endregion

                    #region Serialize OptionalSubmessage
                    Submessage? g__OptionalSubmessage = OptionalSubmessage;
                    if (g__OptionalSubmessage != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalSubmessage_ID : BinaryPrimitives.ReverseEndianness(OptionalSubmessage_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        ushort g__OptionalSubmessage_ObjectLength = (ushort)g__OptionalSubmessage.Value.GetSize();
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? g__OptionalSubmessage_ObjectLength : BinaryPrimitives.ReverseEndianness(g__OptionalSubmessage_ObjectLength);
                        offset += 2;

                        g__OptionalSubmessage.Value.SerializeInto(buffer, (int)(offset - b));
                        offset += g__OptionalSubmessage_ObjectLength;
                    }
                    #endregion

                    #region Serialize Submessages
                    Submessage[] g__Submessages = Submessages;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Submessages_ID : BinaryPrimitives.ReverseEndianness(Submessages_ID);
                    offset += 2;

                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Submessages?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Submessages?.Length ?? 0));
                    offset += 2;

                    for (int i = 0; i < g__Submessages?.Length; i++)
                    {
                        ushort g__Submessages_ObjectLength = (ushort)g__Submessages[i].GetSize();
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? g__Submessages_ObjectLength : BinaryPrimitives.ReverseEndianness(g__Submessages_ObjectLength);
                        offset += 2;

                        g__Submessages[i].SerializeInto(buffer, (int)(offset - b));
                        offset += g__Submessages_ObjectLength;
                    }
                    #endregion

                    #region Serialize OptionalSubmessages
                    Submessage[]? g__OptionalSubmessages = OptionalSubmessages;
                    if (g__OptionalSubmessages != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalSubmessages_ID : BinaryPrimitives.ReverseEndianness(OptionalSubmessages_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__OptionalSubmessages?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__OptionalSubmessages?.Length ?? 0));
                        offset += 2;

                        for (int i = 0; i < g__OptionalSubmessages?.Length; i++)
                        {
                            ushort g__OptionalSubmessages_ObjectLength = (ushort)g__OptionalSubmessages[i].GetSize();
                            *((ushort*)offset) = BitConverter.IsLittleEndian ? g__OptionalSubmessages_ObjectLength : BinaryPrimitives.ReverseEndianness(g__OptionalSubmessages_ObjectLength);
                            offset += 2;

                            g__OptionalSubmessages[i].SerializeInto(buffer, (int)(offset - b));
                            offset += g__OptionalSubmessages_ObjectLength;
                        }
                    }
                    #endregion



                    return (int)(offset - b);
                }
            }
        }

        public static TestMessage Deserialize(byte[] buffer, int start, int length)
        {
            TestMessage value = new TestMessage();
            value.Unpack(buffer, start, length);
            return value;
        }

        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;

                    int readsCompleted = 0;
                    bool g__Content_Read = false;
                    bool g__Body_Read = false;
                    bool g__FloAT_Read = false;
                    bool g__Double_Read = false;
                    bool g__Long_Read = false;
                    bool g__uLong_Read = false;
                    bool g__Ulong_Read = false;
                    bool g__Short_Read = false;
                    bool g__UShort_Read = false;
                    bool g__Bool_Read = false;
                    bool g__Byte_Read = false;
                    bool g__Bytes_Read = false;
                    bool g__OptionalStrings_Read = false;
                    bool g__Int_Read = false;
                    bool g__OptionalInt_Read = false;
                    bool g__Ints_Read = false;
                    bool g__OptionalInts_Read = false;
                    bool g__UInt_Read = false;
                    bool g__OptionalUInt_Read = false;
                    bool g__UInts_Read = false;
                    bool g__OptionalUInts_Read = false;
                    bool g__Enum_Read = false;
                    bool g__OptionalEnum_Read = false;
                    bool g__Enums_Read = false;
                    bool g__OptionalEnums_Read = false;
                    bool g__Submessage_Read = false;
                    bool g__OptionalSubmessage_Read = false;
                    bool g__Submessages_Read = false;
                    bool g__OptionalSubmessages_Read = false;


                    while (readsCompleted < 29 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;

                        switch (id)
                        {
                            #region Deserialize Content
                            case Content_ID:
                                if (g__Content_Read)
                                {
                                    break;
                                }

                                bool g__Content_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__Content_HasValue)
                                {
                                    ushort g__Content_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__Content_Length == 0)
                                    {
                                        Content = string.Empty;
                                    }
                                    else
                                    {
                                        char* chars = (char*)offset;
                                        if (!BitConverter.IsLittleEndian)
                                        {
                                            for (int n = 0; n < g__Content_Length; n++)
                                            {
                                                *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                                chars += 2;
                                            }
                                        }

                                        Content = new string(chars, 0, g__Content_Length);
                                        offset += 2 * g__Content_Length;
                                    }
                                }
                                else
                                {
                                    Content = null;
                                }


                                g__Content_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Body
                            case Body_ID:
                                if (g__Body_Read)
                                {
                                    break;
                                }

                                ushort g__Body_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__Body_Length == 0)
                                {
                                    Body = string.Empty;
                                }
                                else
                                {
                                    char* chars = (char*)offset;
                                    if (!BitConverter.IsLittleEndian)
                                    {
                                        for (int n = 0; n < g__Body_Length; n++)
                                        {
                                            *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                            chars += 2;
                                        }
                                    }

                                    Body = new string(chars, 0, g__Body_Length);
                                    offset += 2 * g__Body_Length;
                                }


                                g__Body_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize FloAT
                            case FloAT_ID:
                                if (g__FloAT_Read)
                                {
                                    break;
                                }

                                uint g__FloAT_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                                FloAT = *(float*)&g__FloAT_Raw;
                                offset += 4;


                                g__FloAT_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Double
                            case Double_ID:
                                if (g__Double_Read)
                                {
                                    break;
                                }

                                ulong g__Double_Raw = BitConverter.IsLittleEndian ? *((ulong*)offset) : BinaryPrimitives.ReverseEndianness(*((ulong*)offset));
                                Double = *(double*)&g__Double_Raw;
                                offset += 8;


                                g__Double_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Long
                            case Long_ID:
                                if (g__Long_Read)
                                {
                                    break;
                                }

                                Long = BitConverter.IsLittleEndian ? *((long*)offset) : BinaryPrimitives.ReverseEndianness(*((long*)offset));
                                offset += 8;


                                g__Long_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize uLong
                            case uLong_ID:
                                if (g__uLong_Read)
                                {
                                    break;
                                }

                                uLong = BitConverter.IsLittleEndian ? *((ulong*)offset) : BinaryPrimitives.ReverseEndianness(*((ulong*)offset));
                                offset += 8;


                                g__uLong_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Ulong
                            case Ulong_ID:
                                if (g__Ulong_Read)
                                {
                                    break;
                                }

                                Ulong = BitConverter.IsLittleEndian ? *((ulong*)offset) : BinaryPrimitives.ReverseEndianness(*((ulong*)offset));
                                offset += 8;


                                g__Ulong_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Short
                            case Short_ID:
                                if (g__Short_Read)
                                {
                                    break;
                                }

                                Short = BitConverter.IsLittleEndian ? *((short*)offset) : BinaryPrimitives.ReverseEndianness(*((short*)offset));
                                offset += 2;


                                g__Short_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize UShort
                            case UShort_ID:
                                if (g__UShort_Read)
                                {
                                    break;
                                }

                                UShort = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;


                                g__UShort_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Bool
                            case Bool_ID:
                                if (g__Bool_Read)
                                {
                                    break;
                                }

                                Bool = *((byte*)offset) == 0 ? false : true;
                                offset += 1;


                                g__Bool_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Byte
                            case Byte_ID:
                                if (g__Byte_Read)
                                {
                                    break;
                                }

                                Byte = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                                offset += 1;


                                g__Byte_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Bytes
                            case Bytes_ID:
                                if (g__Bytes_Read)
                                {
                                    break;
                                }

                                ushort g__Bytes_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__Bytes_Length == 0)
                                {
                                    Bytes = Array.Empty<byte>();
                                }
                                else
                                {
                                    Bytes = new byte[g__Bytes_Length];

                                    for (int i = 0; i < g__Bytes_Length; i++)
                                    {
                                        Bytes[i] = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                                        offset += 1;
                                    }
                                }


                                g__Bytes_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalStrings
                            case OptionalStrings_ID:
                                if (g__OptionalStrings_Read)
                                {
                                    break;
                                }

                                bool g__OptionalStrings_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalStrings_HasValue)
                                {
                                    ushort g__OptionalStrings_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__OptionalStrings_Length == 0)
                                    {
                                        OptionalStrings = Array.Empty<string>();
                                    }
                                    else
                                    {
                                        OptionalStrings = new string[g__OptionalStrings_Length];

                                        for (int i = 0; i < g__OptionalStrings_Length; i++)
                                        {
                                            ushort g__OptionalStrings_i_length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                            offset += 2;

                                            char* chars = (char*)offset;
                                            if (!BitConverter.IsLittleEndian)
                                            {
                                                for (int n = 0; n < g__OptionalStrings_i_length; n++)
                                                {
                                                    *((ushort*)chars) = BinaryPrimitives.ReverseEndianness(*((ushort*)chars));
                                                    chars += 2;
                                                }
                                            }

                                            OptionalStrings[i] = new string(chars, 0, g__OptionalStrings_i_length);
                                            offset += 2 * g__OptionalStrings_i_length;
                                        }
                                    }
                                }


                                g__OptionalStrings_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Int
                            case Int_ID:
                                if (g__Int_Read)
                                {
                                    break;
                                }

                                Int = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                                offset += 4;


                                g__Int_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalInt
                            case OptionalInt_ID:
                                if (g__OptionalInt_Read)
                                {
                                    break;
                                }

                                bool g__OptionalInt_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalInt_HasValue)
                                {
                                    OptionalInt = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                                    offset += 4;
                                }
                                else
                                {
                                    OptionalInt = null;
                                }


                                g__OptionalInt_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Ints
                            case Ints_ID:
                                if (g__Ints_Read)
                                {
                                    break;
                                }

                                ushort g__Ints_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__Ints_Length == 0)
                                {
                                    Ints = Array.Empty<int>();
                                }
                                else
                                {
                                    Ints = new int[g__Ints_Length];

                                    for (int i = 0; i < g__Ints_Length; i++)
                                    {
                                        Ints[i] = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                                        offset += 4;
                                    }
                                }


                                g__Ints_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalInts
                            case OptionalInts_ID:
                                if (g__OptionalInts_Read)
                                {
                                    break;
                                }

                                bool g__OptionalInts_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalInts_HasValue)
                                {
                                    ushort g__OptionalInts_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__OptionalInts_Length == 0)
                                    {
                                        OptionalInts = Array.Empty<int>();
                                    }
                                    else
                                    {
                                        OptionalInts = new int[g__OptionalInts_Length];

                                        for (int i = 0; i < g__OptionalInts_Length; i++)
                                        {
                                            OptionalInts[i] = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                                            offset += 4;
                                        }
                                    }
                                }
                                else
                                {
                                    OptionalInts = null;
                                }


                                g__OptionalInts_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize UInt
                            case UInt_ID:
                                if (g__UInt_Read)
                                {
                                    break;
                                }

                                UInt = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                                offset += 4;


                                g__UInt_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalUInt
                            case OptionalUInt_ID:
                                if (g__OptionalUInt_Read)
                                {
                                    break;
                                }

                                bool g__OptionalUInt_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalUInt_HasValue)
                                {
                                    OptionalUInt = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                                    offset += 4;
                                }
                                else
                                {
                                    OptionalUInt = null;
                                }


                                g__OptionalUInt_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize UInts
                            case UInts_ID:
                                if (g__UInts_Read)
                                {
                                    break;
                                }

                                ushort g__UInts_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__UInts_Length == 0)
                                {
                                    UInts = Array.Empty<uint>();
                                }
                                else
                                {
                                    UInts = new uint[g__UInts_Length];

                                    for (int i = 0; i < g__UInts_Length; i++)
                                    {
                                        UInts[i] = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                                        offset += 4;
                                    }
                                }


                                g__UInts_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalUInts
                            case OptionalUInts_ID:
                                if (g__OptionalUInts_Read)
                                {
                                    break;
                                }

                                bool g__OptionalUInts_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalUInts_HasValue)
                                {
                                    ushort g__OptionalUInts_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__OptionalUInts_Length == 0)
                                    {
                                        OptionalUInts = Array.Empty<uint>();
                                    }
                                    else
                                    {
                                        OptionalUInts = new uint[g__OptionalUInts_Length];

                                        for (int i = 0; i < g__OptionalUInts_Length; i++)
                                        {
                                            OptionalUInts[i] = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                                            offset += 4;
                                        }
                                    }
                                }
                                else
                                {
                                    OptionalUInts = null;
                                }


                                g__OptionalUInts_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Enum
                            case Enum_ID:
                                if (g__Enum_Read)
                                {
                                    break;
                                }

                                Enum = (TestEnum)(BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset)));
                                offset += 4;


                                g__Enum_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalEnum
                            case OptionalEnum_ID:
                                if (g__OptionalEnum_Read)
                                {
                                    break;
                                }

                                bool g__OptionalEnum_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalEnum_HasValue)
                                {
                                    OptionalEnum = (TestEnum)(BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset)));
                                    offset += 4;
                                }
                                else
                                {
                                    OptionalEnum = null;
                                }


                                g__OptionalEnum_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Enums
                            case Enums_ID:
                                if (g__Enums_Read)
                                {
                                    break;
                                }

                                ushort g__Enums_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__Enums_Length == 0)
                                {
                                    Enums = Array.Empty<TestEnum>();
                                }
                                else
                                {
                                    Enums = new TestEnum[g__Enums_Length];

                                    for (int i = 0; i < g__Enums_Length; i++)
                                    {
                                        Enums[i] = (TestEnum)(BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset)));
                                        offset += 4;
                                    }
                                }


                                g__Enums_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalEnums
                            case OptionalEnums_ID:
                                if (g__OptionalEnums_Read)
                                {
                                    break;
                                }

                                bool g__OptionalEnums_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalEnums_HasValue)
                                {
                                    ushort g__OptionalEnums_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__OptionalEnums_Length == 0)
                                    {
                                        OptionalEnums = Array.Empty<TestEnum>();
                                    }
                                    else
                                    {
                                        OptionalEnums = new TestEnum[g__OptionalEnums_Length];

                                        for (int i = 0; i < g__OptionalEnums_Length; i++)
                                        {
                                            OptionalEnums[i] = (TestEnum)(BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset)));
                                            offset += 4;
                                        }
                                    }
                                }
                                else
                                {
                                    OptionalEnums = null;
                                }


                                g__OptionalEnums_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Submessage
                            case Submessage_ID:
                                if (g__Submessage_Read)
                                {
                                    break;
                                }

                                ushort g__Submessage_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;
                                int g__Submessage_Start = (int)(offset - b);
                                Submessage.Unpack(buffer, g__Submessage_Start, g__Submessage_ObjectLength);
                                offset += g__Submessage_ObjectLength;


                                g__Submessage_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalSubmessage
                            case OptionalSubmessage_ID:
                                if (g__OptionalSubmessage_Read)
                                {
                                    break;
                                }

                                bool g__OptionalSubmessage_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalSubmessage_HasValue)
                                {
                                    ushort g__OptionalSubmessage_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;
                                    int g__OptionalSubmessage_Start = (int)(offset - b);
                                    if (OptionalSubmessage == null)
                                    {
                                        OptionalSubmessage = Submessage.Deserialize(buffer, g__OptionalSubmessage_Start, g__OptionalSubmessage_ObjectLength);
                                    }
                                    else
                                    {
                                        OptionalSubmessage.Value.Unpack(buffer, g__OptionalSubmessage_Start, g__OptionalSubmessage_ObjectLength);
                                    }
                                    offset += g__OptionalSubmessage_ObjectLength;
                                }
                                else
                                {
                                    OptionalSubmessage = null;
                                }


                                g__OptionalSubmessage_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize Submessages
                            case Submessages_ID:
                                if (g__Submessages_Read)
                                {
                                    break;
                                }

                                ushort g__Submessages_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                offset += 2;

                                if (g__Submessages_Length == 0)
                                {
                                    Submessages = Array.Empty<Submessage>();
                                }
                                else
                                {
                                    Submessages = new Submessage[g__Submessages_Length];

                                    for (int i = 0; i < g__Submessages_Length; i++)
                                    {
                                        ushort g__Submessages_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                        offset += 2;
                                        int g__Submessages_Start = (int)(offset - b);
                                        Submessages[i].Unpack(buffer, g__Submessages_Start, g__Submessages_ObjectLength);
                                        offset += g__Submessages_ObjectLength;
                                    }
                                }


                                g__Submessages_Read = true;
                                readsCompleted++;
                                break;
                            #endregion

                            #region Deserialize OptionalSubmessages
                            case OptionalSubmessages_ID:
                                if (g__OptionalSubmessages_Read)
                                {
                                    break;
                                }

                                bool g__OptionalSubmessages_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalSubmessages_HasValue)
                                {
                                    ushort g__OptionalSubmessages_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                    offset += 2;

                                    if (g__OptionalSubmessages_Length == 0)
                                    {
                                        OptionalSubmessages = Array.Empty<Submessage>();
                                    }
                                    else
                                    {
                                        OptionalSubmessages = new Submessage[g__OptionalSubmessages_Length];

                                        for (int i = 0; i < g__OptionalSubmessages_Length; i++)
                                        {
                                            ushort g__OptionalSubmessages_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                                            offset += 2;
                                            int g__OptionalSubmessages_Start = (int)(offset - b);
                                            OptionalSubmessages[i].Unpack(buffer, g__OptionalSubmessages_Start, g__OptionalSubmessages_ObjectLength);
                                            offset += g__OptionalSubmessages_ObjectLength;
                                        }
                                    }
                                }
                                else
                                {
                                    OptionalSubmessages = null;
                                }


                                g__OptionalSubmessages_Read = true;
                                readsCompleted++;
                                break;
                                #endregion


                        }
                    }

                    return (int)(offset - b);
                }
            }
        }

    }

    public struct Submessage
    {
        #region Field identifiers
        private const ushort OptionalInt_ID = 0;
        #endregion

        public int? OptionalInt;

        public Submessage(int? _OptionalInt)
        {
            OptionalInt = _OptionalInt;

        }

        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;

            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion

            #region Static size calculation
            #endregion

            const int minLength = 0;

            int length = minLength;

            #region Dynamic size calculation
            if (OptionalInt != null)
            {
                length += optionalFieldLen + intLen;
            }

            #endregion

            return length;
        }

        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }

        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;

                    #region Serialize OptionalInt
                    int? g__OptionalInt = OptionalInt;
                    if (g__OptionalInt != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OptionalInt_ID : BinaryPrimitives.ReverseEndianness(OptionalInt_ID);
                        offset += 2;

                        *((byte*)offset) = (byte)1;
                        offset += 1;

                        *((int*)offset) = BitConverter.IsLittleEndian ? g__OptionalInt.Value : BinaryPrimitives.ReverseEndianness(g__OptionalInt.Value);
                        offset += 4;
                    }
                    #endregion



                    return (int)(offset - b);
                }
            }
        }

        public static Submessage Deserialize(byte[] buffer, int start, int length)
        {
            Submessage value = new Submessage();
            value.Unpack(buffer, start, length);
            return value;
        }

        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;

                    int readsCompleted = 0;
                    bool g__OptionalInt_Read = false;


                    while (readsCompleted < 1 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;

                        switch (id)
                        {
                            #region Deserialize OptionalInt
                            case OptionalInt_ID:
                                if (g__OptionalInt_Read)
                                {
                                    break;
                                }

                                bool g__OptionalInt_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;

                                if (g__OptionalInt_HasValue)
                                {
                                    OptionalInt = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                                    offset += 4;
                                }
                                else
                                {
                                    OptionalInt = null;
                                }


                                g__OptionalInt_Read = true;
                                readsCompleted++;
                                break;
                                #endregion


                        }
                    }

                    return (int)(offset - b);
                }
            }
        }

    }

}
